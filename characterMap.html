<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Character Map</title>

<style>
body {
    font-family: 'Georgia', serif;
    margin: 0;
    padding: 0;
    background-color: #d9f0d9;
    color: #2e4d2e;
    overflow: hidden;
}

h1 {
    margin: 0;
    padding: 25px 0;
    text-align: center;
    background-color: #a8d5a8;
    color: #2e4d2e;
    font-family: 'Palatino Linotype', serif;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

#mapArea {
    width: 100vw;
    height: calc(100vh - 80px);
    position: relative;
    overflow: auto;
    background-color: #c7e6c7;
    border-top: 2px solid #b0d6b0;
}

.charBox {
    position: absolute;
    background-color: #e0f4e0;
    border: 2px solid #b0d6b0;
    border-radius: 12px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.15);
    padding: 8px;
    width: 160px;
    min-width: 120px;
    resize: both;
    overflow: auto;
    cursor: grab;
    transition: background-color 0.2s ease;
    z-index: 10;
}

.charBox:hover { background-color: #d4f0d4; }
.charBox:active { cursor: grabbing; }

.charBox h3 {
    margin: 0 0 4px 0;
    font-size: 14px;
    text-align: center;
    color: #2e4d2e;
}

.meta {
    font-size: 13px;
    text-align: center;
    margin-top: 4px;
    color: #2e4d2e;
}

.traits {
    margin-top: 6px;
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    justify-content: center;
}

.trait {
    background: #a8d5a8;
    padding: 3px 6px;
    border-radius: 6px;
    font-size: 11px;
    color: #2e4d2e;
}
</style>
</head>

<body>

<h1 id="headerTitle">Character Map</h1>

<div id="mapArea"></div>

<script>
/* -----------------------
   LOAD STORY
----------------------- */
const params = new URLSearchParams(window.location.search);
const title = params.get("title");

let novels = JSON.parse(localStorage.getItem("novels")) || [];
let story = novels.find(n => n.title === title);
if (story) story.mapPositions = story.mapPositions || [];

if (!story) {
    document.getElementById("mapArea").innerHTML =
        "<h2 style='padding:20px;color:#922'>Story not found.</h2>";
} else {
    document.getElementById("headerTitle").textContent =
        story.title + " Character Map";
    renderCharacters();
}

/* -----------------------
   Helpers
----------------------- */
function persistNovels() {
    localStorage.setItem("novels", JSON.stringify(novels));
}

function toNum(v) {
    if (v === undefined || v === null) return 0;
    if (typeof v === "number") return v;
    return Number(String(v).replace("px","")) || 0;
}

/* -----------------------
   Clamp box inside map (for DRAGGING ONLY)
----------------------- */
function clampBoxToBounds(box, map) {
    const mapW = map.clientWidth;
    const mapH = map.clientHeight;

    let left = toNum(box.style.left);
    let top = toNum(box.style.top);

    const boxW = box.offsetWidth;
    const boxH = box.offsetHeight;

    if (left < 0) left = 0;
    if (top < 0) top = 0;
    if (left + boxW > mapW) left = mapW - boxW;
    if (top + boxH > mapH) top = mapH - boxH;

    box.style.left = left + "px";
    box.style.top = top + "px";
}

/* -----------------------
   Enforce max size during RESIZING (no shifting)
----------------------- */
function enforceResizeLimits(box) {
    const map = document.getElementById("mapArea");
    const mapW = map.clientWidth;
    const mapH = map.clientHeight;

    const rect = box.getBoundingClientRect();
    const mapRect = map.getBoundingClientRect();

    const left = rect.left - mapRect.left + map.scrollLeft;
    const top = rect.top - mapRect.top + map.scrollTop;

    const maxWidth = mapW - left - 30;
    const maxHeight = mapH - top - 30;

    // stop growth, not reposition
    if (box.offsetWidth > maxWidth) {
        box.style.width = maxWidth + "px";
    }

    if (box.offsetHeight > maxHeight) {
        box.style.height = maxHeight + "px";
    }
}

/* -----------------------
   Save positions
----------------------- */
function savePositions() {
    const map = document.getElementById("mapArea");
    const mapW = map.clientWidth;
    const mapH = map.clientHeight;

    const boxes = document.querySelectorAll(".charBox");

    story.mapPositions = Array.from(boxes).map(box => {
        const leftPx = toNum(box.style.left);
        const topPx = toNum(box.style.top);

        return {
            index: box.dataset.index,
            leftPx,
            topPx,
            leftPct: leftPx / mapW,
            topPct: topPx / mapH,
            width: box.style.width || window.getComputedStyle(box).width,
            height: box.style.height || window.getComputedStyle(box).height
        };
    });

    persistNovels();
    updateLines();
}

/* -----------------------
   Rescale after resize
----------------------- */
function rescaleAndClamp() {
    const map = document.getElementById("mapArea");
    const mapW = map.clientWidth;
    const mapH = map.clientHeight;

    document.querySelectorAll(".charBox").forEach((box, index) => {
        const saved = story.mapPositions.find(p => p.index == index);
        if (!saved) return;

        const newLeft = saved.leftPct * mapW;
        const newTop = saved.topPct * mapH;

        box.style.left = newLeft + "px";
        box.style.top = newTop + "px";

        clampBoxToBounds(box, map);

        saved.leftPx = toNum(box.style.left);
        saved.topPx = toNum(box.style.top);
    });

    persistNovels();
    updateLines();
}

/* -----------------------
   Render characters
----------------------- */
function renderCharacters() {
    const map = document.getElementById("mapArea");
    map.innerHTML = "";

    // canvas for relationship lines
    const canvas = document.createElement("canvas");
    canvas.id = "relationshipCanvas";
    canvas.style.position = "absolute";
    canvas.style.top = "0";
    canvas.style.left = "0";
    canvas.style.width = "100%";
    canvas.style.height = "100%";
    canvas.style.pointerEvents = "none";
    canvas.style.zIndex = "1";
    map.appendChild(canvas);

    const mapW = map.clientWidth;
    const mapH = map.clientHeight;

    story.characters.forEach((c, index) => {
        const saved = story.mapPositions.find(p => p.index == index);

        const box = document.createElement("div");
        box.className = "charBox";
        box.dataset.index = index;

        if (saved) {
            box.style.left = saved.leftPct * mapW + "px";
            box.style.top = saved.topPct * mapH + "px";
            if (saved.width) box.style.width = saved.width;
            if (saved.height) box.style.height = saved.height;

            clampBoxToBounds(box, map);
        } else {
            // non-overlapping default
            const cols = 5;
            const col = index % cols;
            const row = Math.floor(index / cols);

            const left = 50 + col * 200;
            const top = 50 + row * 150;

            box.style.left = left + "px";
            box.style.top = top + "px";

            story.mapPositions.push({
                index,
                leftPx: left,
                topPx: top,
                leftPct: left / mapW,
                topPct: top / mapH,
                width: box.style.width,
                height: box.style.height
            });
        }

        box.innerHTML = `
            <h3>${c.firstName || ""} ${c.lastName || ""}</h3>
            <div class="meta">
                ${c.age ? "Age: " + c.age : ""}
                ${c.gender ? " â€¢ " + c.gender : ""}
            </div>
            <div class="traits">
                ${(c.personalityTraits || []).map(t => `<div class="trait">${t}</div>`).join("")}
            </div>
        `;

        map.appendChild(box);
        enableDraggingAndResizing(box);
    });

    persistNovels();
    updateLines();
}

/* -----------------------
   Lines (only colouring added)
----------------------- */
function updateLines() {
    const canvas = document.getElementById("relationshipCanvas");
    const ctx = canvas.getContext("2d");
    const map = document.getElementById("mapArea");

    canvas.width = map.scrollWidth;
    canvas.height = map.scrollHeight;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = "#2e4d2e";
    ctx.lineWidth = 2;

    const boxes = document.querySelectorAll(".charBox");
    const drawn = new Set();

    // Colour map by category
    const relationshipColours = {
        Romantic: "#ffbbe7",
        Family: "#c3b1e1",
        Friendship: "#ffee8c",
        "Work / Professional": "#779ecb",
        "Conflict / Rivalry": "#c23b22",
        Other: "#ff964f",
        Default: "#2e4d2e"
    };

    // normalized -> category map (lowercase keys)
    const relationshipCategoryMap = {
        "dating":"Romantic","engaged":"Romantic","ex-partners":"Romantic","lovers":"Romantic","married":"Romantic","situationship":"Romantic",
        "adoptive parent/adoptive child":"Family","aunt/uncle and niece/nephew":"Family","foster parent/foster child":"Family","grandparent/grandchild":"Family",
        "great grandparent/great grandchild":"Family","great great grandparent/great great grandchild":"Family","half-siblings":"Family","parent/child":"Family",
        "siblings":"Family","step-parent/step-child":"Family","step-siblings":"Family",
        "classmates":"Friendship","club members":"Friendship","family friends":"Friendship","friends":"Friendship","mentor":"Friendship",
        "neighbour":"Friendship","roommate":"Friendship","teacher/student":"Friendship","teammates":"Friendship",
        "boss/employee":"Work / Professional","client/service provider":"Work / Professional","co-workers":"Work / Professional",
        "bully/victim":"Conflict / Rivalry","enemies":"Conflict / Rivalry","frenemies":"Conflict / Rivalry","rivals":"Conflict / Rivalry","secret ally":"Conflict / Rivalry",
        "other (see details)":"Other","pet/owner":"Other"
    };

    story.characters.forEach((c, index) => {
        (c.relationships || []).forEach(rel => {
            const target = rel.relatedTo;
            if (!target) return;

            const otherIndex = story.characters.findIndex(
                char => char.firstName === target.firstName &&
                        char.lastName === target.lastName
            );
            if (otherIndex === -1 || otherIndex === index) return;

            const key = `${Math.min(index, otherIndex)}-${Math.max(index, otherIndex)}`;
            if (drawn.has(key)) return;
            drawn.add(key);

            const b1 = boxes[index];
            const b2 = boxes[otherIndex];
            if (!b1 || !b2) return;

            const r1 = b1.getBoundingClientRect();
            const r2 = b2.getBoundingClientRect();
            const mapRect = map.getBoundingClientRect();

            const x1 = r1.left + r1.width/2 - mapRect.left + map.scrollLeft;
            const y1 = r1.top + r1.height/2 - mapRect.top + map.scrollTop;
            const x2 = r2.left + r2.width/2 - mapRect.left + map.scrollLeft;
            const y2 = r2.top + r2.height/2 - mapRect.top + map.scrollTop;

            // --- COLOUR SELECTION (only added logic) ---
            const rawType = (rel.relationshipType ?? rel.type ?? rel.nature ?? rel.relation ?? rel.kind ?? "").toString();
            const normalized = rawType.trim().toLowerCase();
            const category = relationshipCategoryMap[normalized] || "Default";
            const color = relationshipColours[category] || relationshipColours.Default;
            // ------------------------------------------------

            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = color; // set colour right before stroking
            ctx.stroke();
        });
    });
}


/* -----------------------
   Drag + Resize logic
----------------------- */
function enableDraggingAndResizing(box) {
    let dragging = false;
    let offsetX = 0, offsetY = 0;

    /* ---- DRAGGING ---- */
    box.addEventListener("mousedown", e => {
        if (e.offsetX > box.clientWidth - 15 && e.offsetY > box.clientHeight - 15) return;

        dragging = true;
        box.style.cursor = "grabbing";
        offsetX = e.clientX - box.offsetLeft;
        offsetY = e.clientY - box.offsetTop;
    });

    window.addEventListener("mousemove", e => {
        if (!dragging) return;

        const map = document.getElementById("mapArea");

        let left = e.clientX - offsetX;
        let top = e.clientY - offsetY;

        box.style.left = left + "px";
        box.style.top = top + "px";

        clampBoxToBounds(box, map);
        updateLines();
    });

    window.addEventListener("mouseup", () => {
        if (dragging) savePositions();
        dragging = false;
        box.style.cursor = "grab";
    });

    /* ---- RESIZING ---- */
    let oldW = box.offsetWidth;
    let oldH = box.offsetHeight;

    const observer = new ResizeObserver(() => {
        // enforce max size without moving the box
        enforceResizeLimits(box);

        // detect real resize
        const changed = (
            oldW !== box.offsetWidth ||
            oldH !== box.offsetHeight
        );

        oldW = box.offsetWidth;
        oldH = box.offsetHeight;

        if (changed) savePositions();
    });

    observer.observe(box);
}

/* -----------------------
   Window resize fix
----------------------- */
let resizeDebounce = null;
window.addEventListener("resize", () => {
    if (resizeDebounce) clearTimeout(resizeDebounce);

    resizeDebounce = setTimeout(() => {
        rescaleAndClamp();
    }, 150);
});

/* -----------------------
   Normalize stored positions
----------------------- */
function normalizeStoredPositions() {
    const map = document.getElementById("mapArea");
    const mapW = map.clientWidth;
    const mapH = map.clientHeight;

    story.mapPositions = (story.mapPositions || []).map(p => {
        const leftPx = toNum(p.leftPx);
        const topPx = toNum(p.topPx);

        return {
            index: p.index,
            leftPx,
            topPx,
            leftPct: p.leftPct ?? leftPx / mapW,
            topPct: p.topPct ?? topPx / mapH,
            width: p.width,
            height: p.height
        };
    });

    persistNovels();
}

normalizeStoredPositions();
</script>

</body>
</html>
