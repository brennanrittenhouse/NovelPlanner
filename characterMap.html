<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Character Map</title>

<style>
body {
    font-family: 'Georgia', serif;
    margin: 0;
    padding: 0;
    background-color: #d9f0d9;
    color: #2e4d2e;
    overflow: hidden;
}

h1 {
    margin: 0;
    padding: 25px 0;
    text-align: center;
    background-color: #a8d5a8;
    color: #2e4d2e;
    font-family: 'Palatino Linotype', serif;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

#mapArea {
    width: 100vw;
    height: calc(100vh - 80px);
    position: relative;
    overflow: auto;
    background-color: #c7e6c7;
    border-top: 2px solid #b0d6b0;
}

.charBox {
    position: absolute;
    background-color: #e0f4e0;
    border: 2px solid #b0d6b0;
    border-radius: 12px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.15);
    padding: 8px;
    width: 160px;
    min-width: 120px;
    resize: both;
    overflow: auto;
    cursor: grab;
    transition: background-color 0.2s ease;
    z-index: 10;
}

.charBox:hover { background-color: #d4f0d4; }
.charBox:active { cursor: grabbing; }

.charBox h3 {
    margin: 0 0 4px 0;
    font-size: 14px;
    text-align: center;
    color: #2e4d2e;
}

.meta {
    font-size: 13px;
    text-align: center;
    margin-top: 4px;
    color: #2e4d2e;
}

.traits {
    margin-top: 6px;
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    justify-content: center;
}

.trait {
    background: #a8d5a8;
    padding: 3px 6px;
    border-radius: 6px;
    font-size: 11px;
    color: #2e4d2e;
}
</style>
</head>

<body>

<h1 id="headerTitle">Character Map</h1>

<div id="mapArea"></div>

<script>
/* -----------------------
   LOAD STORY
----------------------- */
const params = new URLSearchParams(window.location.search);
const title = params.get("title");

let novels = JSON.parse(localStorage.getItem("novels")) || [];
let story = novels.find(n => n.title === title);
if (story) story.mapPositions = story.mapPositions || [];

if (!story) {
    document.getElementById("mapArea").innerHTML =
        "<h2 style='padding:20px;color:#922'>Story not found.</h2>";
} else {
    document.getElementById("headerTitle").textContent =
        story.title + " Character Map";
    renderCharacters();
}

/* -----------------------
   Helpers
----------------------- */
function persistNovels() {
    localStorage.setItem("novels", JSON.stringify(novels));
}

function toNum(v) {
    if (v === undefined || v === null) return 0;
    if (typeof v === "number") return v;
    return Number(String(v).replace("px","")) || 0;
}

/* -----------------------
   Clamp box inside map
----------------------- */
function clampBoxToBounds(box, map) {
    const mapW = map.clientWidth;
    const mapH = map.clientHeight;

    let left = toNum(box.style.left);
    let top = toNum(box.style.top);

    const boxW = box.offsetWidth;
    const boxH = box.offsetHeight;

    if (left < 0) left = 0;
    if (top < 0) top = 0;

    if (left + boxW > mapW) left = mapW - boxW;
    if (top + boxH > mapH) top = mapH - boxH;

    box.style.left = left + "px";
    box.style.top = top + "px";
}

/* -----------------------
   Save positions
----------------------- */
function savePositions() {
    const map = document.getElementById("mapArea");
    const mapW = map.clientWidth;
    const mapH = map.clientHeight;

    const boxes = document.querySelectorAll(".charBox");

    story.mapPositions = Array.from(boxes).map(box => {
        const leftPx = toNum(box.style.left);
        const topPx = toNum(box.style.top);

        return {
            index: box.dataset.index,
            leftPx,
            topPx,
            leftPct: leftPx / mapW,
            topPct: topPx / mapH,
            width: box.style.width || window.getComputedStyle(box).width,
            height: box.style.height || window.getComputedStyle(box).height
        };
    });

    persistNovels();
    updateLines();
}

/* -----------------------
   Rescale boxes after resize
----------------------- */
function rescaleAndClamp() {
    const map = document.getElementById("mapArea");
    const mapW = map.clientWidth;
    const mapH = map.clientHeight;
    const boxes = document.querySelectorAll(".charBox");

    boxes.forEach((box, idx) => {
        const saved = story.mapPositions.find(p => p.index == idx);
        if (!saved) return;

        // compute new pixel coords from stored percentages
        const left = saved.leftPct * mapW;
        const top = saved.topPct * mapH;

        box.style.left = left + "px";
        box.style.top = top + "px";

        // also clamp so nothing is cut off
        clampBoxToBounds(box, map);

        // update stored px values so reload is correct
        saved.leftPx = toNum(box.style.left);
        saved.topPx = toNum(box.style.top);
    });

    persistNovels();
    updateLines();
}

/* -----------------------
   RENDER CHARACTERS
----------------------- */
function renderCharacters() {
    const map = document.getElementById("mapArea");
    map.innerHTML = "";

    // relationship canvas
    const canvas = document.createElement("canvas");
    canvas.id = "relationshipCanvas";
    canvas.style.position = "absolute";
    canvas.style.top = "0";
    canvas.style.left = "0";
    canvas.style.width = "100%";
    canvas.style.height = "100%";
    canvas.style.pointerEvents = "none";
    canvas.style.zIndex = "1";
    map.appendChild(canvas);

    const mapW = map.clientWidth;
    const mapH = map.clientHeight;

    story.characters.forEach((c, index) => {
        const saved = story.mapPositions.find(p => p.index == index);

        const box = document.createElement("div");
        box.className = "charBox";
        box.dataset.index = index;

        if (saved) {
            const left = saved.leftPct * mapW;
            const top = saved.topPct * mapH;

            box.style.left = left + "px";
            box.style.top = top + "px";

            if (saved.width) box.style.width = saved.width;
            if (saved.height) box.style.height = saved.height;

            // clamp on initial load
            clampBoxToBounds(box, map);
        } else {
            /* -------------------------------
               UPDATED NON-OVERLAPPING INITIAL
               LAYOUT (ONLY CHANGE MADE)
            -------------------------------- */
            const BOX_W = 200; // width spacing
            const BOX_H = 170; // height spacing

            const cols = Math.max(1, Math.floor(mapW / BOX_W));
            const col = index % cols;
            const row = Math.floor(index / cols);

            const left = 30 + col * BOX_W;
            const top = 30 + row * BOX_H;

            box.style.left = left + "px";
            box.style.top = top + "px";

            story.mapPositions.push({
                index,
                leftPx: left,
                topPx: top,
                leftPct: left / mapW,
                topPct: top / mapH,
                width: box.style.width,
                height: box.style.height
            });
        }

        box.innerHTML = `
            <h3>${c.firstName || ""} ${c.lastName || ""}</h3>
            <div class="meta">
                ${c.age ? "Age: " + c.age : ""}
                ${c.gender ? " â€¢ " + c.gender : ""}
            </div>
            <div class="traits">
                ${(c.personalityTraits || []).map(t => `<div class="trait">${t}</div>`).join("")}
            </div>
        `;

        map.appendChild(box);
        enableDragging(box);
    });

    persistNovels();
    updateLines();
}

/* -----------------------
   UPDATE RELATIONSHIP LINES
----------------------- */
function updateLines() {
    const canvas = document.getElementById("relationshipCanvas");
    const ctx = canvas.getContext("2d");
    const map = document.getElementById("mapArea");

    canvas.width = map.scrollWidth;
    canvas.height = map.scrollHeight;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = "#2e4d2e";
    ctx.lineWidth = 2;

    const boxes = document.querySelectorAll(".charBox");
    const drawn = new Set();

    story.characters.forEach((c, index) => {
        (c.relationships || []).forEach(rel => {
            const target = rel.relatedTo;
            if (!target) return;

            const otherIndex = story.characters.findIndex(
                char => char.firstName === target.firstName &&
                        char.lastName === target.lastName
            );
            if (otherIndex === -1 || otherIndex === index) return;

            const key = `${Math.min(index, otherIndex)}-${Math.max(index, otherIndex)}`;
            if (drawn.has(key)) return;
            drawn.add(key);

            const b1 = boxes[index];
            const b2 = boxes[otherIndex];
            if (!b1 || !b2) return;

            const r1 = b1.getBoundingClientRect();
            const r2 = b2.getBoundingClientRect();
            const mapRect = map.getBoundingClientRect();

            const x1 = r1.left + r1.width / 2 - mapRect.left + map.scrollLeft;
            const y1 = r1.top + r1.height / 2 - mapRect.top + map.scrollTop;
            const x2 = r2.left + r2.width / 2 - mapRect.left + map.scrollLeft;
            const y2 = r2.top + r2.height / 2 - mapRect.top + map.scrollTop;

            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        });
    });
}

/* -----------------------
   DRAGGING
----------------------- */
function enableDragging(box) {
    let dragging = false;
    let offsetX = 0, offsetY = 0;

    box.addEventListener("mousedown", e => {
        if (e.offsetX > box.clientWidth - 15 && e.offsetY > box.clientHeight - 15) return;

        dragging = true;
        box.style.cursor = "grabbing";

        offsetX = e.clientX - box.offsetLeft;
        offsetY = e.clientY - box.offsetTop;
    });

    window.addEventListener("mousemove", e => {
        if (!dragging) return;

        const map = document.getElementById("mapArea");

        let left = e.clientX - offsetX;
        let top = e.clientY - offsetY;

        box.style.left = left + "px";
        box.style.top = top + "px";

        clampBoxToBounds(box, map);
        updateLines();
    });

    window.addEventListener("mouseup", () => {
        if (dragging) {
            savePositions();
        }
        dragging = false;
        box.style.cursor = "grab";
    });

    new ResizeObserver(() => {
        savePositions();
    }).observe(box);
}

/* -----------------------
   FIX FOR MAC ZOOM
----------------------- */
let resizeDebounce = null;
window.addEventListener("resize", () => {
    if (resizeDebounce) clearTimeout(resizeDebounce);

    resizeDebounce = setTimeout(() => {
        rescaleAndClamp();
    }, 150);
});

/* -----------------------
   Normalize
----------------------- */
function normalizeStoredPositions() {
    const map = document.getElementById("mapArea");
    const mapW = map.clientWidth;
    const mapH = map.clientHeight;

    story.mapPositions = (story.mapPositions || []).map(p => {
        const leftPx = toNum(p.leftPx);
        const topPx = toNum(p.topPx);

        return {
            index: p.index,
            leftPx,
            topPx,
            leftPct: p.leftPct ?? leftPx / mapW,
            topPct: p.topPct ?? topPx / mapH,
            width: p.width,
            height: p.height
        };
    });

    persistNovels();
}

normalizeStoredPositions();
</script>

</body>
</html>
